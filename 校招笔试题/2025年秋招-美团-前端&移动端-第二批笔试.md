> 使用 ts 做 OJ 编程题，有一些注意点：
>
> 1. `require` 导致的类型报错，需要我们在自己本地项目安装依赖 `npm i -D types/node`。
> 2. 使用 `npx tsx xxx.ts` 运行，终端会持续监听，输入换行和其他语言一样，但是最后停止输入，需要我们手动 ctrl + d 结束（git bash），或者手动两下 ctrl + d 结束（power shell）。

试题地址：https://www.nowcoder.com/exam/test/93732190/detail?pid=63316195&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FquestionJobId%3D10%26subTabName%3Dwritten_page

题目：2025年秋招-美团-前端&移动端-第二批笔试

![f3658095-99a9-4fe5-a82c-7515f57833cf](https://raw.githubusercontent.com/Shelden-Hao/images/main/images202511272337091.png)

```ts
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let input: string[] = [];
rl.on('line', (line: string) => {
    input.push(line.trim());
});

rl.on('close', () => {
    let idx = 0;
    const T = parseInt(input[idx++]);

    let outputs: string[] = [];

    for (let _ = 0; _ < T; _++) {
        const n = parseInt(input[idx++]);
        const arr = input[idx++].split(' ').map(Number);

        let sum0 = 0;
        let maxA = 0;
        for (let v of arr) {
            sum0 += v;
            if (v > maxA) maxA = v;
        }

        // 找 maxA 的最高位
        let msb = 0;
        if (maxA > 0) {
            msb = 31 - Math.clz32(maxA);
        } else {
            msb = 0; // 当 maxA = 0 时 位数视为 1，允许 k=0
        }

        let x = 0;
        let add = 0;

        for (let k = 0; k <= msb; k++) {
            let cnt1 = 0;
            for (let v of arr) {
                if ((v >> k) & 1) cnt1++;
            }
            if (cnt1 < n) {
                // 存在至少一个 0，可增益
                x |= (1 << k);
                add += (1 << k);
            }
        }

        outputs.push(`${sum0 + add} ${x}`);
    }

    console.log(outputs.join('\n'));
});

```

![f3658095-99a9-4fe5-a82c-7515f57833cf](https://raw.githubusercontent.com/Shelden-Hao/images/main/images202511272345217.png)

```ts
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

let lines: string[] = [];
rl.on('line', (line: string) => {
  lines.push(line.trim());
});
rl.on('close', () => {
  let idx = 0;
  const t = parseInt(lines[idx++], 10);
  const outputs: string[] = [];

  // 大顶堆（BigInt）
  class MaxHeap {
    a: bigint[];
    constructor() { this.a = []; }
    size() { return this.a.length; }
    peek(): bigint { return this.a[0]; }
    push(x: bigint) {
      this.a.push(x);
      this._siftUp(this.a.length - 1);
    }
    pop(): bigint | undefined {
      if (this.a.length === 0) return undefined;
      const top = this.a[0];
      const last = this.a.pop()!;
      if (this.a.length > 0) {
        this.a[0] = last;
        this._siftDown(0);
      }
      return top;
    }
    _siftUp(i: number) {
      const a = this.a;
      let idx = i;
      while (idx > 0) {
        const p = Math.floor((idx - 1) / 2);
        if (a[p] >= a[idx]) break;
        [a[p], a[idx]] = [a[idx], a[p]];
        idx = p;
      }
    }
    _siftDown(i: number) {
      const a = this.a;
      let idx = i;
      const n = a.length;
      while (true) {
        let l = idx * 2 + 1;
        let r = idx * 2 + 2;
        let largest = idx;
        if (l < n && a[l] > a[largest]) largest = l;
        if (r < n && a[r] > a[largest]) largest = r;
        if (largest === idx) break;
        [a[idx], a[largest]] = [a[largest], a[idx]];
        idx = largest;
      }
    }
  }

  // popcount for BigInt -> returns BigInt
  function popcountBigInt(x: bigint): bigint {
    const s = x.toString(2);
    let cnt = 0;
    for (let i = 0; i < s.length; i++) {
      if (s[i] === '1') cnt++;
    }
    return BigInt(cnt);
  }

  for (let tc = 0; tc < t; tc++) {
    const n = parseInt(lines[idx++], 10);
    const A_tokens = lines[idx++].split(/\s+/).filter((s: string) => s.length);
    const B_tokens = lines[idx++].split(/\s+/).filter((s: string) => s.length);

    const heapA = new MaxHeap();
    const heapB = new MaxHeap();

    for (let i = 0; i < n; i++) {
      heapA.push(BigInt(A_tokens[i]));
    }
    for (let i = 0; i < n; i++) {
      heapB.push(BigInt(B_tokens[i]));
    }

    let ops = 0;

    while (heapA.size() > 0 && heapB.size() > 0) {
      const a = heapA.peek();
      const b = heapB.peek();
      if (a === b) {
        heapA.pop();
        heapB.pop();
      } else if (a > b) {
        heapA.pop();
        const na = popcountBigInt(a);
        heapA.push(na);
        ops++;
      } else { // b > a
        heapB.pop();
        const nb = popcountBigInt(b);
        heapB.push(nb);
        ops++;
      }
    }

    outputs.push(String(ops));
  }

  console.log(outputs.join('\n'));
});
```

